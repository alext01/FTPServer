     This is Evan's proposal for the overall flow of the ftp server. This
is not to be considered a final draft, but a template we can work with so that
it will be more easy to combine all of our work at a later time. There will be
undoubtedly situations I have not considered, and problems dealing with
pthreads given my current lack of understanding on this topic.

     The purpose of this proposal is so that we can figure out what can/will
be available to us while working with functions at a deeper level into the
program. Also, I wish to have a greater understanding of how I can handle the
connections, select(), socket reading/writing, etc. Basically, I wish to avoid
rewriting as much code as possible in the futer.

     I will provide a summary of the files and functions that will be required
for the server to function under this proposal. After the summary I will
provide commented (psuedoish) code that displays the general idea expressed in
the summary. For example, variables will not be declared and the naming of each
function will be general. Functions will for the most part have empty arguments.

Revision 1 of this file.
    -Added some code for mutex locking in main() and pthread().
    -Added a note about where to declare list pointer variables in pthread().






-------------------------------------------------------------------------------
File: main.c
-------------------------------------------------------------------------------
Requirements for main():
     -Initialize a linked list for new control connections to be appended to.
     -Create sockets to accept conrol connections.
     -Accept control connections with all/any clients.
     -Read standard input from the console running the server.
     -Start a pthread process for each accepted control connection.
     -Signal shutdown when the appropriate input is read stdin.
     -Exit the program when all threads have been terminated.

     I will not add any special notes to main() at this time. The requirements
and and "code" block below will suffice for the time being.
-------------------------------------------------------------------------------

/* Global variable each thread can check. Set this to true if the server is 
 * shutting down. */
int shutdown = FALSE;

/* Create a mutex. Only one of any: server or thread my alter any node in this
 * linked list at one time. No exceptions or results will be undefined.
pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER;

/* This mutex can be locked and any global variables appearing under it will not
 * be allowed to be changed by any process not holding the lock. */
//Initialize the linked list of pthreads.
struct llist *node;

int main (int argc, char *argv[])
{
     //Create a socket for all available interfaces to accept connections.
     createControlSockets();

     //Lock the mutex
     lock(mymutex);
     //initialize the linked list (any modification to the list will include a lock) node = create_head();
     //Unlock the mutex so others can now modify the linked list (remove themselves) unlock(mymutex);

     //Begin the main loop. We will break from this loop with the command "shutdown" entered on the server console.
     while (1) {
     	   //Accept a control connection. Read commands entered on stdin file descriptor.
	   sfd = controlAccept();		

	   //Exit the loop if the shutdown command was entered.
	   //We could add more server commands if we so wish near this block.
	   if (sfd == SHUTDOWN) {
	       break;
           }

	   //Create a linked list node. The address of this node will be passed to our pthread, so the pthread may remove it on completion.
	   node = addListNode(sfd);

	   //Create a pthread to begin an ftp session. Pass the node" so that when the session is 
	   //Complete the thread can remove itself from the linked list.
	   pthread_create (node->thread, , , pthread(node), );

	   //Detach the thread as explained in this answer: http://stackoverflow.com/a/6043021
	   //We do not have to join the pthread, and the thread can close itself.
	   pthread_detatch (node->thread);
     }

     //Each thread will check the global shutdown variable after completing the current transfer or when their select timesout (e.g. 10 seconds).
     //When shutdown is detected, send message code 421, and return from session() to close all thread memory/sockets (see "session.c").
     shutdown = TRUE;

     //When all threads have terminated themselves, the linked list will be empty, and main can return.
     while (listIsEmpty != 0)
          sleep(1); //something to stop while from passing at maximum speed.

     //Program may terminate without error.
     return 0;
}
-------------------------------------------------------------------------------
END OF MAIN.C                                                                 
-------------------------------------------------------------------------------










-------------------------------------------------------------------------------
file: session.c
function: pthread()
-------------------------------------------------------------------------------
Requirements for pthread.c:
    -Create a pointer variable for anything that we will malloc.
    -Transfer control of the thread process to the function session().
    -Close all open sockets and free any heap memory that is still reachable.
    -Remove the linked list node that was created in main.
    -Terminate the thread.

    This function's purpose is to ensure all sockets will be closed, and all
heap memory will be freed before the thread terminates. This will remove
extra complication to the session() select loop. 

    All threads will begin and end in this function. Alternatively, and this is
most likely preferential, include these pointers in the linked list node. The 
difference is this: if we include these pointers in this function, only this
particular thread may alter this information. The upside is the data is
protected and no mutex will slow down the process. The downside is that main()
will have to dutifully wait for the thread to terminate itself, it may not
intervene and just close sockets and/or free memory on the threads behalf.

The list of potential uses of heap memory at this time:
    -If/when we choose to implement block and/or compressed mode for data
     transmissions, It will become possible to queue files to be sent or
     recieved. In this case we will need a queue of all of the transmissions.
-------------------------------------------------------------------------------

void pthread (struct llist *node)
{
     //A pointer to all variables a session uses that is malloc'd must be included at this time.
     struct queue *ptr = NULL;

     //This may be required if pthread_exit() is needed in this function. See the bottom statment of this function.
     pthread_t handle = node->thread;

     //Begin the session.
     session (c_sfd, d_sfd, cmd_que_ptr);

     //Close all sockets.
     close (c_sfd);	 //control connection socket
     close (d_sfd);	  //data connection socket

     //Ensure all pointers declared at the top of this function are NULL.
     //Free this memory (all nodes if a list or queue) if it is not NULL.
     if (variable != NULL)
     	free_list_function (ptr);

     //Remove (free) the linked list node created in main.
     //NOTE: if this is not possible due to the thread handle being located inside the
     //      linked list, set the sfd variable to 0 and have main iterate and remove the 0 value nodes on occasion.
     //
     //NOTE: There is a possibility that multiple threads may try to alter a linked list node at the same time.
     //      We will need to use a posix thread "mutex" when removing a linked list node.
     removeNode (node);

     //Exit the pthread if that's how it works, or let the function return....I need to do a little research here.
     pthread_exit (handle); 
}
-------------------------------------------------------------------------------
END OF FUNCTION PTHREAD()
-------------------------------------------------------------------------------









-------------------------------------------------------------------------------
file: session.c
function: session()
-------------------------------------------------------------------------------
Requirements for session.c:
    -Monitor the global variable shutdown, return from function if TRUE.
    -Monitor the control connection socket for client commands.
    -Accept any connections on an unconnected PASV socket.
    -Monitor the data connection socket if the server is to recieve a file.
     eg. STOR.

Potential futer requirements:
    -If we wish to implement the ABORT command, etc. we will likely need to
     have any file transfers over the data connection socket be on another thread.
     If this has been implemented, this function would terminate that thread
     upon recieving an ABORT command, or call a function to do so.

    This function can be viewed as the main() function for each thread process. All
sockets that should be checked for nonblocking read/write will be done so here.
Control will be passed from this function the functions that perform the client
commands such as STOR, RETR, PASV, etc.
-------------------------------------------------------------------------------

int session (node) {

    //Check if the server is shutting down.
    if (shutdown == TRUE) {
       send_mesg_421();    //server is shutting down.
       return 0;
    }

    //Configure a read set, data connection may be included depending on what type of data connection transfer is expected. eg STOR.
    FD_ZERO (&rfds);
    FD_SET (the sockets);

    //Configure a write set
    FD_ZERO (&wfds);
    FD_SET (the sockets);

    //Set a timeout for select. This will ensure the shutdown variable will be checked if the control connection becomes idle.
    struct timeval = (10 seconds perhaps);
    
    //Check for nonblocking I/O
    select ();

    //Process the data.
}

At this point I have expressed most of my ideas for the server I wished to propose.
The function above was cut short in this file in the case that we do not follow
this proposal whatsoever I do not wish to waste my time. If we do wish to implement
the server this way, or use a function similar to this, the function will be complex
enough that it would be better explained with comments to the actual code.

I am completely open to any changes the group wishes to make, and I do not guarantee
that this server is functional. I have never created a server before so this is only
what I envision could work.

Me or someone else could change or expand this document at a later time if we choose
to do something similar to this.

Thank you for reading this,
Evan
